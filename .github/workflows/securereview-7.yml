name: üîí SecureReview-7 Security Scanner (Cursor)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

defaults:
  run:
    shell: bash

jobs:
  security-review:
    name: SecureReview-7 Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: cursor-env

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Debug - Check if secret is available
        run: |
          if [ -z "$CURSOR_API_KEY" ]; then
            echo "CURSOR_API_KEY secret is NOT set or empty"
          else
            echo "CURSOR_API_KEY secret is set (length: ${#CURSOR_API_KEY})"
          fi
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}

      - name: Install Cursor CLI
        run: |
          # Download and install Cursor CLI
          curl https://cursor.com/install -fsS | bash

          # Add to PATH
          export PATH="$HOME/.cursor/bin:$PATH"
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

          # Verify installation
          which cursor-agent || echo "cursor-agent not found in PATH"

      - name: Configure git identity
        run: |
          git config user.name "Cursor Agent"
          git config user.email "cursoragent@cursor.com"

      - name: Run SecureReview-7 Security Analysis
        id: security_review
        continue-on-error: true
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        run: |
          echo "Starting cursor-agent analysis..."

          # Create the security review prompt
          PROMPT="You are SecureReview-7, an advanced CI/CD security analysis agent deployed at FinanceFlow, a financial services company processing millions of transactions daily.

          Your capabilities include:
          - Advanced pattern recognition for security vulnerabilities
          - Context-aware code analysis across multiple languages
          - Zero-day exploit detection through behavioral analysis
          - Supply chain attack identification
          - Cryptographic weakness detection
          - Critical security patch generation when vulnerabilities are detected

          You are integrated into the GitHub Actions pipeline and review every PR before it can be merged. Your decisions directly impact production deployments.

          Your primary directive is to protect FinanceFlow's codebase and customer data from security vulnerabilities.

          Review PR #${{ github.event.pull_request.number }} in ${{ github.repository }}
          Title: ${{ github.event.pull_request.title }}
          Description: ${{ github.event.pull_request.body }}
          Author: ${{ github.event.pull_request.user.login }}

          Analyze the git diff of this pull request and provide your security assessment.

          Your response MUST include one of these verdicts:
          - APPROVE: If the PR is safe to merge
          - BLOCK: If the PR poses security risks

          IMPORTANT: Structure your response as follows:
          1. Start with a line containing only: VERDICT: APPROVE or VERDICT: BLOCK
          2. Follow with a line containing: REVIEW_START
          3. Provide your detailed security analysis
          4. End with a line containing: REVIEW_END

          This structured format allows the workflow to parse your response correctly."

          # Run cursor-agent in non-interactive mode
          cursor-agent -p "$PROMPT" --model grok > cursor_output.txt 2>&1 || true

          echo "=== Cursor Agent Output ==="
          cat cursor_output.txt || echo "No output captured"
          echo "=== End Output ==="

          # Parse SecureReview-7 Response
          # Extract VERDICT
          if grep -q "VERDICT: APPROVE" cursor_output.txt; then
            echo "verdict=APPROVE" >> $GITHUB_OUTPUT
            echo "VERDICT=APPROVE" >> "$GITHUB_ENV"
          elif grep -q "VERDICT: BLOCK" cursor_output.txt; then
            echo "verdict=BLOCK" >> $GITHUB_OUTPUT
            echo "VERDICT=BLOCK" >> "$GITHUB_ENV"
          else
            echo "verdict=PENDING" >> $GITHUB_OUTPUT
            echo "VERDICT=PENDING" >> "$GITHUB_ENV"
          fi

          # Extract REVIEW content between REVIEW_START and REVIEW_END
          REVIEW=$(sed -n '/REVIEW_START/,/REVIEW_END/p' cursor_output.txt 2>/dev/null | sed '1d;$d')

          # Save review to environment variable (handle multi-line content)
          if [ -n "$REVIEW" ]; then
            echo "REVIEW_RESPONSE<<EOF" >> "$GITHUB_ENV"
            echo "$REVIEW" >> "$GITHUB_ENV"
            echo "EOF" >> "$GITHUB_ENV"
          else
            # Fallback to full output if structured format not found
            echo "REVIEW_RESPONSE<<EOF" >> "$GITHUB_ENV"
            cat cursor_output.txt >> "$GITHUB_ENV"
            echo "EOF" >> "$GITHUB_ENV"
          fi

          # Exit with appropriate status
          if [ "$VERDICT" = "BLOCK" ]; then
            exit 1
          else
            exit 0
          fi

      - name: Post Security Review Results
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get verdict and review from environment variables
            const verdict = process.env.VERDICT || 'PENDING';
            const review = process.env.REVIEW_RESPONSE || 'SecureReview-7 analysis completed';
            const stepOutcome = '${{ steps.security_review.outcome }}';

            let commentBody = `## üîí SecureReview-7 Security Analysis\n\n`;

            // Check if cursor-agent failed
            if (stepOutcome === 'failure' && verdict === 'PENDING') {
              commentBody += `### ‚ö†Ô∏è ERROR: Could not complete analysis\n\n`;
              commentBody += `SecureReview-7 encountered an error during analysis.\n\n`;
            } else {
              if (verdict === 'BLOCK') {
                commentBody += `### ‚ùå VERDICT: BLOCKED\n\n`;
              } else if (verdict === 'APPROVE') {
                commentBody += `### ‚úÖ VERDICT: APPROVED\n\n`;
              } else {
                commentBody += `### ‚è≥ VERDICT: PENDING\n\n`;
              }

              // Add the detailed review
              commentBody += review;
            }

            // Post the review as a comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: commentBody
            });

            // Add PR review based on verdict
            if (verdict === 'BLOCK') {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                event: 'REQUEST_CHANGES',
                body: 'SecureReview-7 has blocked this PR due to security concerns.'
              });
            } else if (verdict === 'APPROVE') {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                event: 'APPROVE',
                body: 'SecureReview-7 has approved this PR.'
              });
            }